<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ”¹è‰¯ç‰ˆï¼šæ»‘ã‚‰ã‹ãªãƒœãƒ­ãƒã‚¤åœ°å½¢ç”Ÿæˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-wrapper {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            width: 100%;
            border: 1px solid #ddd;
        }
        h2 {
            margin-top: 0;
            font-size: 18px;
            color: #555;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        .legend-color {
            width: 30px;
            height: 20px;
            border: 1px solid #333;
        }
        .explanation {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .explanation h3 {
            color: #333;
            margin-top: 0;
        }
        .explanation ul {
            line-height: 1.8;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 5px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <h1>æ”¹è‰¯ç‰ˆï¼šæ»‘ã‚‰ã‹ãªãƒœãƒ­ãƒã‚¤åœ°å½¢ç”Ÿæˆ</h1>
    
    <div class="controls">
        <button onclick="regenerate()">ğŸ”„ åœ°å½¢ã‚’å†ç”Ÿæˆ</button>
    </div>

    <div class="container">
        <div class="canvas-wrapper">
            <h2>â‘  ãƒœãƒ­ãƒã‚¤åˆ†å‰² + å¤§é ˜åŸŸã‚°ãƒ«ãƒ¼ãƒ—åŒ–</h2>
            <canvas id="structure" width="600" height="600"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>é€šè·¯ï¼ˆç·©ã‚„ã‹ãªå‚ã€å¤§é ˜åŸŸé–“ï¼‰</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>å£ï¼ˆå´–ã€å¤§é ˜åŸŸé–“ï¼‰</span>
                </div>
                <div class="legend-item">
                    <span>è‰²ä»˜ãé ˜åŸŸï¼šå¤§é ˜åŸŸï¼ˆè¤‡æ•°ã‚»ãƒ«ã®é›†åˆï¼‰</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <h2>â‘¡ é«˜åº¦ä¼æ’­ï¼ˆå¤§é ˜åŸŸå˜ä½ï¼‰</h2>
            <canvas id="heightNumbers" width="600" height="600"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <span>å„å¤§é ˜åŸŸã®åŸºæº–é«˜åº¦ã¨é€šè·¯æ–¹å‘</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <h2>â‘¢ æ»‘ã‚‰ã‹ãªåœ°å½¢ï¼ˆç´°éƒ¨ã¾ã§å‚¾æ–œï¼‰</h2>
            <canvas id="smoothTerrain" width="600" height="600"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(to right, #0066cc, #66b3ff, #90EE90, #FFD700, #ff6b35, #8B4513);"></div>
                    <span>ä½ â†’ é«˜ï¼ˆè°· â†’ å±±ï¼‰ã‚»ãƒ«å†…éƒ¨ãŒæ»‘ã‚‰ã‹ã«å‚¾æ–œ</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper full-width">
            <h2>â‘£ ä¸‰æ¬¡å…ƒä¿¯ç°å›³ï¼ˆç­‰è§’æŠ•å½±ï¼‰</h2>
            <canvas id="isometric3D" width="1200" height="800"></canvas>
        </div>
    </div>

    <div class="explanation">
        <h3>âœ¨ æ”¹è‰¯ãƒã‚¤ãƒ³ãƒˆ</h3>
        <ul>
            <li><strong>äºŒæ®µéšã‚·ã‚¹ãƒ†ãƒ ï¼š</strong> ç´°ã‹ã„ãƒœãƒ­ãƒã‚¤ã‚»ãƒ«ï¼ˆ100å€‹ï¼‰ã‚’å¤§é ˜åŸŸï¼ˆ15å€‹ã€å¤§ä¸­å°ã®ã‚µã‚¤ã‚ºå·®ã‚ã‚Šï¼‰ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã€‚å¢ƒç•Œã¯æœ‰æ©Ÿçš„ã§ã€é€šè·¯ã¯åºƒãè‡ªç„¶ã€‚</li>
            <li><strong>éå¸¸ã«è‡ªç„¶ãªå¢ƒç•Œç·šï¼š</strong> 100ã®ç´°ã‹ã„ã‚»ãƒ«ã«ã‚ˆã‚Šã€å¢ƒç•ŒãŒã‚ˆã‚Šæ»‘ã‚‰ã‹ãªæ›²ç·šçŠ¶ã«ã€‚Lloyd's relaxationã§å‡ç­‰é…ç½®ã€‚</li>
            <li><strong>å¤§ä¸­å°ã®ã‚µã‚¤ã‚ºå·®ï¼š</strong> å¤§é ˜åŸŸã«å¤§ï¼ˆ20%ï¼‰ã€ä¸­ï¼ˆ50%ï¼‰ã€å°ï¼ˆ30%ï¼‰ã®ã‚µã‚¤ã‚ºãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã€‚ã‚ˆã‚Šå¤šæ§˜ãªåœ°å½¢ã«ã€‚</li>
            <li><strong>é©åˆ‡ãªé«˜åº¦å·®ï¼š</strong> é€šè·¯ã§ç¹‹ãŒã‚‹éš£æ¥é ˜åŸŸã¯å°ã•ãªé«˜åº¦å·®ï¼ˆ5-12mï¼‰ã€‚å‰ã®çŠ¶æ…‹ã‚’è€ƒæ…®ï¼ˆä¸ŠãŒã‚Šå‚¾å‘ãƒ»ä¸‹ãŒã‚Šå‚¾å‘ï¼‰ã—ã¦é«˜ä½ãŒç”Ÿã¾ã‚Œã‚„ã™ãã€‚</li>
            <li><strong>éå¸¸ã«åºƒã„å½±éŸ¿ç¯„å›²ï¼š</strong> é«˜åº¦å·®ã«å¿œã˜ã¦å‚ã®å½±éŸ¿ç¯„å›²ã‚’è‡ªå‹•èª¿æ•´ï¼ˆé«˜åº¦å·®5mâ†’ç¯„å›²300pxã€15mâ†’900pxï¼‰ã€‚å¤§é ˜åŸŸã®ä¸­å¿ƒã‹ã‚‰å‚ãŒå§‹ã¾ã‚‹ã€‚</li>
            <li><strong>æ»‘ã‚‰ã‹ãªå´–ï¼š</strong> å´–ã®ç¯„å›²ã‚’10-40ãƒ”ã‚¯ã‚»ãƒ«ã«æ‹¡å¤§ã—ã€ã¹ãä¹—ã‚’1.5ã«ç·©å’Œã€‚æ€¥å³»ã§ã‚‚æ»‘ã‚‰ã‹ã«ã¤ãªãŒã‚‹ã€‚ç¸æ¨¡æ§˜ã‚’è§£æ¶ˆã€‚</li>
            <li><strong>ã¤ã¥ã‚‰å‚ï¼š</strong> ã‚»ãƒ«å†…éƒ¨ã¯é€šè·¯å¢ƒç•Œã«å‘ã‹ã£ã¦éå¸¸ã«ç·©ã‚„ã‹ã«å‚¾æ–œã€‚ã¹ãä¹—0.5ã§æ¥µã‚ã¦æ»‘ã‚‰ã‹ã€‚</li>
            <li><strong>3Dä¿¯ç°å›³ï¼ˆå…¨ä½“è¡¨ç¤ºï¼‰ï¼š</strong> ç­‰è§’æŠ•å½±ã«ã‚ˆã‚Šåœ°å½¢å…¨ä½“ã‚’å°‘ã—ä¸Šã‹ã‚‰å¯è¦–åŒ–ã€‚é«˜åº¦ã‚’2å€ã«å¼·èª¿ã—ã¦ç«‹ä½“æ„Ÿã‚’è¡¨ç¾ã€‚</li>
        </ul>
    </div>

    <script>
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        class VoronoiCell {
            constructor(id, point) {
                this.id = id;
                this.point = point;
                this.neighbors = new Set();
                this.groupId = null; // ã©ã®å¤§é ˜åŸŸã«å±ã™ã‚‹ã‹
                this.baseHeight = null;
                this.boundaryHeights = new Map();
            }
        }
        
        class RegionGroup {
            constructor(id) {
                this.id = id;
                this.cells = new Set(); // ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«å±ã™ã‚‹ã‚»ãƒ«
                this.neighborGroups = new Set(); // éš£æ¥ã™ã‚‹å¤§é ˜åŸŸ
                this.baseHeight = null;
            }
        }

        class ImprovedVoronoi {
            constructor(width, height, numSites, numGroups) {
                this.width = width;
                this.height = height;
                this.cells = [];
                this.groups = [];
                this.edges = new Map();
                this.groupEdges = new Map(); // ã‚°ãƒ«ãƒ¼ãƒ—é–“ã®ã‚¨ãƒƒã‚¸ï¼ˆé€šè·¯/å£ï¼‰
                
                // ç´°ã‹ã„ãƒœãƒ­ãƒã‚¤ã‚»ãƒ«ã‚’ç”Ÿæˆ
                for (let i = 0; i < numSites; i++) {
                    const cell = new VoronoiCell(
                        i,
                        new Point(
                            Math.random() * width,
                            Math.random() * height
                        )
                    );
                    this.cells.push(cell);
                }
                
                // Lloyd's relaxationã§æ¯ç‚¹ã‚’å‡ç­‰ã«é…ç½®
                this.relaxLloyd(3);
                
                this.buildNeighborGraph();
                
                // ã‚»ãƒ«ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦å¤§é ˜åŸŸã‚’ä½œã‚‹
                this.groupCells(numGroups);
                
                // å¤§é ˜åŸŸé–“ã§è¿·è·¯ã‚’ç”Ÿæˆ
                this.generateGroupMaze();
                
                // å¤§é ˜åŸŸã«é«˜åº¦ã‚’å‰²ã‚Šå½“ã¦
                this.propagateGroupHeights();
                
                // ã‚»ãƒ«ãƒ¬ãƒ™ãƒ«ã§å¢ƒç•Œé«˜åº¦ã‚’è¨ˆç®—
                this.calculateCellBoundaryHeights();
            }
            
            groupCells(numGroups) {
                // ã‚·ãƒ¼ãƒ‰ã‚»ãƒ«ã‚’é¸æŠï¼ˆã§ãã‚‹ã ã‘é›¢ã‚ŒãŸä½ç½®ï¼‰
                const seeds = [];
                seeds.push(Math.floor(Math.random() * this.cells.length));
                
                while (seeds.length < numGroups) {
                    let maxMinDist = -1;
                    let bestCandidate = -1;
                    
                    for (let i = 0; i < this.cells.length; i++) {
                        if (seeds.includes(i)) continue;
                        
                        let minDist = Infinity;
                        for (const seedId of seeds) {
                            const dist = this.cells[i].point.distanceTo(this.cells[seedId].point);
                            minDist = Math.min(minDist, dist);
                        }
                        
                        if (minDist > maxMinDist) {
                            maxMinDist = minDist;
                            bestCandidate = i;
                        }
                    }
                    
                    if (bestCandidate !== -1) {
                        seeds.push(bestCandidate);
                    } else {
                        break;
                    }
                }
                
                // ã‚°ãƒ«ãƒ¼ãƒ—ã‚’åˆæœŸåŒ–
                for (let i = 0; i < seeds.length; i++) {
                    const group = new RegionGroup(i);
                    this.groups.push(group);
                    
                    const seedCell = this.cells[seeds[i]];
                    seedCell.groupId = i;
                    group.cells.add(seeds[i]);
                }
                
                // å„ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚µã‚¤ã‚ºï¼ˆå¤§ä¸­å°ï¼‰ã‚’å‰²ã‚Šå½“ã¦
                const groupSizes = [];
                const numLarge = Math.floor(numGroups * 0.2); // 20%ãŒå¤§
                const numMedium = Math.floor(numGroups * 0.5); // 50%ãŒä¸­
                const numSmall = numGroups - numLarge - numMedium; // 30%ãŒå°
                
                for (let i = 0; i < numLarge; i++) groupSizes.push('large');
                for (let i = 0; i < numMedium; i++) groupSizes.push('medium');
                for (let i = 0; i < numSmall; i++) groupSizes.push('small');
                
                // ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                groupSizes.sort(() => Math.random() - 0.5);
                
                // å„ã‚°ãƒ«ãƒ¼ãƒ—ã®ã‚µã‚¤ã‚ºã‚’è¨­å®š
                this.groups.forEach((group, i) => {
                    group.targetSize = groupSizes[i];
                });
                
                // ã‚µã‚¤ã‚ºã‚’è€ƒæ…®ã—ãŸã‚°ãƒ­ãƒ¼ã‚¤ãƒ³ã‚°æ³•ã§å„ã‚»ãƒ«ã‚’ã‚°ãƒ«ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦
                const queue = seeds.map(id => ({cellId: id, groupId: this.cells[id].groupId}));
                const visited = new Set(seeds);
                
                while (queue.length > 0) {
                    const {cellId, groupId} = queue.shift();
                    const group = this.groups[groupId];
                    
                    // ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ç›®æ¨™ã‚µã‚¤ã‚º
                    const totalCells = this.cells.length;
                    let targetCells;
                    if (group.targetSize === 'large') {
                        targetCells = Math.floor(totalCells / numGroups * 1.8); // 1.8å€
                    } else if (group.targetSize === 'medium') {
                        targetCells = Math.floor(totalCells / numGroups * 1.0); // æ¨™æº–
                    } else {
                        targetCells = Math.floor(totalCells / numGroups * 0.6); // 0.6å€
                    }
                    
                    // ç›®æ¨™ã‚µã‚¤ã‚ºã«é”ã—ã¦ã„ãªã„å ´åˆã®ã¿æ‹¡å¤§
                    if (group.cells.size < targetCells) {
                        for (const neighborId of this.cells[cellId].neighbors) {
                            if (!visited.has(neighborId)) {
                                visited.add(neighborId);
                                this.cells[neighborId].groupId = groupId;
                                this.groups[groupId].cells.add(neighborId);
                                queue.push({cellId: neighborId, groupId});
                            }
                        }
                    }
                }
                
                // æœªå‰²ã‚Šå½“ã¦ã®ã‚»ãƒ«ãŒã‚ã‚Œã°æœ€ã‚‚è¿‘ã„ã‚°ãƒ«ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦
                for (let i = 0; i < this.cells.length; i++) {
                    if (!visited.has(i)) {
                        let minDist = Infinity;
                        let closestGroupId = 0;
                        
                        for (let g = 0; g < this.groups.length; g++) {
                            for (const cellId of this.groups[g].cells) {
                                const dist = this.cells[i].point.distanceTo(this.cells[cellId].point);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestGroupId = g;
                                }
                            }
                        }
                        
                        this.cells[i].groupId = closestGroupId;
                        this.groups[closestGroupId].cells.add(i);
                    }
                }
                
                // ã‚°ãƒ«ãƒ¼ãƒ—é–“ã®éš£æ¥é–¢ä¿‚ã‚’æ§‹ç¯‰
                for (let i = 0; i < this.cells.length; i++) {
                    const cell = this.cells[i];
                    for (const neighborId of cell.neighbors) {
                        const neighbor = this.cells[neighborId];
                        if (cell.groupId !== neighbor.groupId) {
                            this.groups[cell.groupId].neighborGroups.add(neighbor.groupId);
                            this.groups[neighbor.groupId].neighborGroups.add(cell.groupId);
                        }
                    }
                }
            }
            
            generateGroupMaze() {
                // ã‚°ãƒ«ãƒ¼ãƒ—é–“ã§è¿·è·¯ã‚’ç”Ÿæˆï¼ˆPrimæ³•ï¼‰
                const visited = new Set([0]);
                const edges = [];
                
                for (const neighborGroupId of this.groups[0].neighborGroups) {
                    edges.push([0, neighborGroupId]);
                }
                
                while (visited.size < this.groups.length && edges.length > 0) {
                    const idx = Math.floor(Math.random() * edges.length);
                    const [from, to] = edges[idx];
                    edges.splice(idx, 1);
                    
                    if (!visited.has(to)) {
                        visited.add(to);
                        this.setGroupEdge(from, to, false); // é€šè·¯
                        
                        for (const neighborGroupId of this.groups[to].neighborGroups) {
                            if (!visited.has(neighborGroupId)) {
                                edges.push([to, neighborGroupId]);
                            }
                        }
                    }
                }
                
                // æ®‹ã‚Šã¯å£
                for (let i = 0; i < this.groups.length; i++) {
                    for (const j of this.groups[i].neighborGroups) {
                        if (i < j && !this.hasGroupEdge(i, j)) {
                            this.setGroupEdge(i, j, true); // å£
                        }
                    }
                }
            }
            
            setGroupEdge(i, j, isWall) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                this.groupEdges.set(key, isWall);
            }
            
            getGroupEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.groupEdges.get(key) || false;
            }
            
            hasGroupEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.groupEdges.has(key);
            }
            
            relaxLloyd(iterations) {
                // Lloyd's relaxation: å„ã‚»ãƒ«ã®é‡å¿ƒã«æ¯ç‚¹ã‚’ç§»å‹•
                for (let iter = 0; iter < iterations; iter++) {
                    const centroids = [];
                    
                    // å„ã‚»ãƒ«ã®é‡å¿ƒã‚’è¨ˆç®—
                    for (let i = 0; i < this.cells.length; i++) {
                        let sumX = 0;
                        let sumY = 0;
                        let count = 0;
                        
                        // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã§ã‚»ãƒ«é ˜åŸŸã‚’ã‚«ãƒãƒ¼
                        const step = 8;
                        for (let y = 0; y < this.height; y += step) {
                            for (let x = 0; x < this.width; x += step) {
                                const p = new Point(x, y);
                                let closestId = 0;
                                let minDist = this.cells[0].point.distanceTo(p);
                                
                                for (let j = 1; j < this.cells.length; j++) {
                                    const dist = this.cells[j].point.distanceTo(p);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        closestId = j;
                                    }
                                }
                                
                                if (closestId === i) {
                                    sumX += x;
                                    sumY += y;
                                    count++;
                                }
                            }
                        }
                        
                        if (count > 0) {
                            centroids.push(new Point(sumX / count, sumY / count));
                        } else {
                            centroids.push(this.cells[i].point);
                        }
                    }
                    
                    // æ¯ç‚¹ã‚’é‡å¿ƒã«ç§»å‹•
                    for (let i = 0; i < this.cells.length; i++) {
                        this.cells[i].point = centroids[i];
                    }
                }
            }
            
            buildNeighborGraph() {
                const step = 5;
                for (let y = 0; y < this.height; y += step) {
                    for (let x = 0; x < this.width; x += step) {
                        const p = new Point(x, y);
                        const sorted = this.cells
                            .map(c => ({cell: c, dist: c.point.distanceTo(p)}))
                            .sort((a, b) => a.dist - b.dist);
                        
                        if (sorted.length >= 2 && sorted[1].dist - sorted[0].dist < 3) {
                            const c1 = sorted[0].cell;
                            const c2 = sorted[1].cell;
                            c1.neighbors.add(c2.id);
                            c2.neighbors.add(c1.id);
                        }
                    }
                }
            }
            
            generateMaze() {
                const visited = new Set([0]);
                const edges = [];
                
                for (const neighbor of this.cells[0].neighbors) {
                    edges.push([0, neighbor]);
                }
                
                while (visited.size < this.cells.length && edges.length > 0) {
                    const idx = Math.floor(Math.random() * edges.length);
                    const [from, to] = edges[idx];
                    edges.splice(idx, 1);
                    
                    if (!visited.has(to)) {
                        visited.add(to);
                        this.setEdge(from, to, false);
                        
                        for (const neighbor of this.cells[to].neighbors) {
                            if (!visited.has(neighbor)) {
                                edges.push([to, neighbor]);
                            }
                        }
                    }
                }
                
                for (let i = 0; i < this.cells.length; i++) {
                    for (const j of this.cells[i].neighbors) {
                        if (i < j && !this.hasEdge(i, j)) {
                            this.setEdge(i, j, true);
                        }
                    }
                }
            }
            
            propagateGroupHeights() {
                // å¹…å„ªå…ˆæ¢ç´¢ã§é«˜åº¦ã‚’å‰²ã‚Šå½“ã¦
                const startGroup = this.groups[0];
                startGroup.baseHeight = 40 + Math.random() * 20; // é–‹å§‹é«˜åº¦ï¼ˆ30-60mï¼‰
                
                const visited = new Set([startGroup.id]);
                const queue = [{group: startGroup, lastDirection: null}]; // å‰å›ã®æ–¹å‘ã‚’è¨˜éŒ²
                
                while (queue.length > 0) {
                    const {group: current, lastDirection} = queue.shift();
                    
                    // é€šè·¯ã§ç¹‹ãŒã‚‹æœªè¨ªå•ã®éš£æ¥ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é›†ã‚ã‚‹
                    const children = [];
                    for (const neighborGroupId of current.neighborGroups) {
                        if (!this.getGroupEdge(current.id, neighborGroupId) && !visited.has(neighborGroupId)) {
                            children.push(neighborGroupId);
                        }
                    }
                    
                    // å„å­ã‚°ãƒ«ãƒ¼ãƒ—ã«é«˜åº¦ã‚’å‰²ã‚Šå½“ã¦
                    children.forEach(neighborGroupId => {
                        visited.add(neighborGroupId);
                        const neighbor = this.groups[neighborGroupId];
                        
                        // é€šè·¯ã§ç¹‹ãŒã£ã¦ã„ã‚‹ã®ã§å°ã•ãªé«˜åº¦å·®ï¼ˆ5-12mï¼‰
                        const heightDiff = 5 + Math.random() * 7;
                        
                        // å‰å›ã®æ–¹å‘ã‚’è€ƒæ…®ã—ãŸç¢ºç‡èª¿æ•´
                        let upProbability;
                        if (lastDirection === 'up') {
                            upProbability = 0.75; // å‰å›ä¸ŠãŒã£ã¦ã„ãŸã‚‰75%ã§ä¸ŠãŒã‚‹
                        } else if (lastDirection === 'down') {
                            upProbability = 0.25; // å‰å›ä¸‹ãŒã£ã¦ã„ãŸã‚‰25%ã§ä¸ŠãŒã‚‹ï¼ˆ75%ã§ä¸‹ãŒã‚‹ï¼‰
                        } else {
                            upProbability = 0.55; // åˆå›ã¯å°‘ã—ä¸ŠãŒã‚Šã‚„ã™ã
                        }
                        
                        const goUp = Math.random() < upProbability;
                        const newDirection = goUp ? 'up' : 'down';
                        
                        if (goUp) {
                            neighbor.baseHeight = Math.min(90, current.baseHeight + heightDiff);
                        } else {
                            neighbor.baseHeight = Math.max(10, current.baseHeight - heightDiff);
                        }
                        
                        queue.push({group: neighbor, lastDirection: newDirection});
                    });
                }
                
                // å£ã§éš”ã¦ã‚‰ã‚ŒãŸéš£æ¥ã‚°ãƒ«ãƒ¼ãƒ—ã®é«˜åº¦å·®ã‚’ç¢ºä¿
                this.ensureGroupWallHeightDifference();
            }
            
            ensureGroupWallHeightDifference() {
                const minDifference = 15;
                
                for (let i = 0; i < this.groups.length; i++) {
                    for (const j of this.groups[i].neighborGroups) {
                        if (i < j && this.getGroupEdge(i, j)) {
                            const group1 = this.groups[i];
                            const group2 = this.groups[j];
                            
                            if (group1.baseHeight == null || group2.baseHeight == null) continue;
                            
                            const diff = Math.abs(group1.baseHeight - group2.baseHeight);
                            if (diff < minDifference) {
                                if (group1.baseHeight > group2.baseHeight) {
                                    group1.baseHeight = Math.min(95, group2.baseHeight + minDifference + Math.random() * 10);
                                } else {
                                    group2.baseHeight = Math.min(95, group1.baseHeight + minDifference + Math.random() * 10);
                                }
                            }
                        }
                    }
                }
            }
            
            calculateCellBoundaryHeights() {
                // å„ã‚»ãƒ«ã«æ‰€å±ã‚°ãƒ«ãƒ¼ãƒ—ã®é«˜åº¦ã‚’å‰²ã‚Šå½“ã¦
                for (const cell of this.cells) {
                    const group = this.groups[cell.groupId];
                    cell.baseHeight = group.baseHeight;
                }
                
                // ã‚»ãƒ«é–“ã®å¢ƒç•Œé«˜åº¦ã‚’è¨ˆç®—
                for (const cell of this.cells) {
                    for (const neighborId of cell.neighbors) {
                        const neighbor = this.cells[neighborId];
                        
                        // åŒã˜ã‚°ãƒ«ãƒ¼ãƒ—å†… or ã‚°ãƒ«ãƒ¼ãƒ—é–“ãŒé€šè·¯ã®å ´åˆ
                        if (cell.groupId === neighbor.groupId || 
                            !this.getGroupEdge(cell.groupId, neighbor.groupId)) {
                            const boundaryHeight = (cell.baseHeight + neighbor.baseHeight) / 2;
                            cell.boundaryHeights.set(neighborId, boundaryHeight);
                        }
                    }
                }
            }
            
            setEdge(i, j, isWall) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                this.edges.set(key, isWall);
            }
            
            getEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.edges.get(key) || false;
            }
            
            hasEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.edges.has(key);
            }
            
            getClosestCell(x, y) {
                const p = new Point(x, y);
                let closest = this.cells[0];
                let minDist = closest.point.distanceTo(p);
                
                for (let i = 1; i < this.cells.length; i++) {
                    const dist = this.cells[i].point.distanceTo(p);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = this.cells[i];
                    }
                }
                
                return {cell: closest, dist: minDist};
            }
            
            getClosestCells(x, y, n = 3) {
                const p = new Point(x, y);
                return this.cells
                    .map(c => ({cell: c, dist: c.point.distanceTo(p)}))
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, n);
            }
        }

        // ãƒ‘ãƒ¼ãƒªãƒ³ãƒã‚¤ã‚ºé¢¨ã®é–¢æ•°
        function simpleNoise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const fx = x - Math.floor(x);
            const fy = y - Math.floor(y);
            
            const hash = (X * 374761393 + Y * 668265263) & 0x7fffffff;
            return (hash / 0x7fffffff) * 2 - 1;
        }

        function perlinNoise(x, y) {
            const X = Math.floor(x);
            const Y = Math.floor(y);
            const fx = x - X;
            const fy = y - Y;
            
            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const u = fade(fx);
            const v = fade(fy);
            
            const n00 = simpleNoise(X, Y);
            const n10 = simpleNoise(X + 1, Y);
            const n01 = simpleNoise(X, Y + 1);
            const n11 = simpleNoise(X + 1, Y + 1);
            
            const nx0 = n00 * (1 - u) + n10 * u;
            const nx1 = n01 * (1 - u) + n11 * u;
            
            return nx0 * (1 - v) + nx1 * v;
        }

        function multiOctaveNoise(x, y) {
            let total = 0;
            let amplitude = 1;
            let frequency = 0.01;
            
            for (let i = 0; i < 4; i++) {
                total += perlinNoise(x * frequency, y * frequency) * amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return total;
        }

        // æ”¹è‰¯ç‰ˆã®é«˜åº¦è¨ˆç®—ï¼ˆç¸æ¨¡æ§˜ã‚’é™¤å»ï¼‰
        function smoothstep(t) {
            t = Math.max(0, Math.min(1, t));
            return t * t * (3 - 2 * t);
        }

        function getImprovedHeight(voronoi, x, y) {
            const p = new Point(x, y);
            
            // æœ€ã‚‚è¿‘ã„ã‚»ãƒ«ã‚’å–å¾—
            const closest = voronoi.getClosestCells(x, y, 5);
            const primaryCell = closest[0].cell;
            
            if (primaryCell.baseHeight == null) return 50;
            
            // ã‚¹ãƒ†ãƒƒãƒ—1: ã“ã®ã‚»ãƒ«ã«é–¢é€£ã™ã‚‹é«˜åº¦å·®ã‚’è¨ˆç®—
            let maxHeightDiff = 0;
            if (primaryCell.boundaryHeights.size > 0) {
                for (const [neighborId, boundaryHeight] of primaryCell.boundaryHeights) {
                    const diff = Math.abs(boundaryHeight - primaryCell.baseHeight);
                    maxHeightDiff = Math.max(maxHeightDiff, diff);
                }
            }
            
            // é«˜åº¦å·®ã«å¿œã˜ã¦å½±éŸ¿ç¯„å›²ã‚’æ±ºå®šï¼ˆå¤§å¹…ã«åºƒã’ã‚‹ï¼‰
            // é«˜åº¦å·®5m â†’ ç¯„å›²300ã€é«˜åº¦å·®15m â†’ ç¯„å›²900ï¼ˆå¤§é ˜åŸŸã®ä¸­å¿ƒã‹ã‚‰å‚ãŒå§‹ã¾ã‚‹ï¼‰
            const baseRange = 300;
            const rangeScale = 60; // é«˜åº¦å·®1mã‚ãŸã‚Š60ãƒ”ã‚¯ã‚»ãƒ«æ‹¡å¤§ï¼ˆ30â†’60ã«å€å¢—ï¼‰
            const influenceRange = baseRange + maxHeightDiff * rangeScale;
            
            // ã‚¹ãƒ†ãƒƒãƒ—2: é ˜åŸŸå…¨ä½“ã®ç·©ã‚„ã‹ãªå‚¾æ–œã‚’è¨ˆç®—ï¼ˆã¤ã¥ã‚‰å‚ï¼‰
            let baseHeight = primaryCell.baseHeight;
            
            // é€šè·¯ã§ç¹‹ãŒã£ã¦ã„ã‚‹éš£æ¥ã‚»ãƒ«ã¸ã®å‚¾æ–œã‚’è¨ˆç®—
            if (primaryCell.boundaryHeights.size > 0) {
                let totalWeight = 0;
                let totalHeight = 0;
                
                // å„é€šè·¯å¢ƒç•Œã‹ã‚‰ã®å½±éŸ¿ã‚’è¨ˆç®—ï¼ˆéå¸¸ã«åºƒã„ç¯„å›²ã§ï¼‰
                for (const [neighborId, boundaryHeight] of primaryCell.boundaryHeights) {
                    const neighbor = voronoi.cells[neighborId];
                    
                    // å¢ƒç•Œã®ä¸­ç‚¹
                    const boundaryX = (primaryCell.point.x + neighbor.point.x) / 2;
                    const boundaryY = (primaryCell.point.y + neighbor.point.y) / 2;
                    const boundaryPoint = new Point(boundaryX, boundaryY);
                    const distToBoundary = p.distanceTo(boundaryPoint);
                    
                    // éå¸¸ã«ç·©ã‚„ã‹ãªé‡ã¿ä»˜ã‘ï¼ˆã‚ˆã‚Šç·©ã‚„ã‹ã«ï¼‰
                    const weight = 1 / (Math.pow(distToBoundary / influenceRange, 0.5) + 0.02);
                    totalWeight += weight;
                    totalHeight += boundaryHeight * weight;
                }
                
                // ã‚»ãƒ«ä¸­å¿ƒã®å½±éŸ¿
                const centerDist = closest[0].dist;
                const centerWeight = 1 / (Math.pow(centerDist / influenceRange, 0.5) + 0.02);
                totalWeight += centerWeight;
                totalHeight += primaryCell.baseHeight * centerWeight;
                
                baseHeight = totalHeight / totalWeight;
            }
            
            // ã‚¹ãƒ†ãƒƒãƒ—3: ã‚»ãƒ«å¢ƒç•Œä»˜è¿‘ã§ã®éš£æ¥ã‚»ãƒ«ã¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰
            let finalHeight = baseHeight;
            
            // éš£æ¥ã‚»ãƒ«ã¨ã®å¢ƒç•Œå‡¦ç†
            for (let i = 1; i < Math.min(4, closest.length); i++) {
                const {cell: otherCell, dist: otherDist} = closest[i];
                
                if (otherCell.baseHeight == null) continue;
                
                const distToBoundary = otherDist - closest[0].dist;
                
                // å¢ƒç•Œã«è¿‘ã„å ´åˆ
                if (distToBoundary < 50) { // 30â†’50ã«æ‹¡å¤§
                    // ã“ã®ã‚»ãƒ«ã¨ã®å¢ƒç•ŒãŒå£ã‹ã©ã†ã‹ç¢ºèª
                    const isWall = voronoi.getEdge(primaryCell.id, otherCell.id);
                    
                    if (isWall) {
                        // å£ã®å ´åˆï¼šé«˜åº¦å·®ã«å¿œã˜ãŸå´–ã‚’ä½œã‚‹
                        const heightDiff = Math.abs(primaryCell.baseHeight - otherCell.baseHeight);
                        
                        // é«˜åº¦å·®ã«å¿œã˜ã¦å´–ã®ç¯„å›²ã‚’èª¿æ•´ï¼ˆå¤§å¹…ã«åºƒã’ã‚‹ï¼‰
                        const cliffRange = Math.min(40, 10 + heightDiff * 1.5); // ç¯„å›²ã‚’10-40ãƒ”ã‚¯ã‚»ãƒ«ã«æ‹¡å¤§
                        
                        if (distToBoundary < cliffRange) {
                            // å¢ƒç•Œä»˜è¿‘ã§å¤‰åŒ–ï¼ˆã‚ˆã‚Šæ»‘ã‚‰ã‹ã«ï¼‰
                            const t = distToBoundary / cliffRange;
                            const sharpT = Math.pow(t, 1.5); // 2.5â†’1.5ã«ç·©å’Œï¼ˆã‚ˆã‚Šæ»‘ã‚‰ã‹ï¼‰
                            
                            // ä»–ã‚»ãƒ«ã®é«˜åº¦ã‚’è¨ˆç®—
                            let otherHeight = otherCell.baseHeight;
                            if (otherCell.boundaryHeights.size > 0) {
                                let otherMaxHeightDiff = 0;
                                for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                    const diff = Math.abs(boundaryHeight - otherCell.baseHeight);
                                    otherMaxHeightDiff = Math.max(otherMaxHeightDiff, diff);
                                }
                                const otherInfluenceRange = baseRange + otherMaxHeightDiff * rangeScale;
                                
                                let otherTotalWeight = 0;
                                let otherTotalHeight = 0;
                                
                                for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                    const neighbor = voronoi.cells[neighborId];
                                    const boundaryX = (otherCell.point.x + neighbor.point.x) / 2;
                                    const boundaryY = (otherCell.point.y + neighbor.point.y) / 2;
                                    const boundaryPoint = new Point(boundaryX, boundaryY);
                                    const distToBoundary = p.distanceTo(boundaryPoint);
                                    
                                    const weight = 1 / (Math.pow(distToBoundary / otherInfluenceRange, 0.5) + 0.02);
                                    otherTotalWeight += weight;
                                    otherTotalHeight += boundaryHeight * weight;
                                }
                                
                                const centerDist = otherDist;
                                const centerWeight = 1 / (Math.pow(centerDist / otherInfluenceRange, 0.5) + 0.02);
                                otherTotalWeight += centerWeight;
                                otherTotalHeight += otherCell.baseHeight * centerWeight;
                                
                                otherHeight = otherTotalHeight / otherTotalWeight;
                            }
                            
                            finalHeight = finalHeight * sharpT + otherHeight * (1 - sharpT);
                        }
                    } else {
                        // é€šè·¯ã®å ´åˆï¼šç·©ã‚„ã‹ãªå‚¾æ–œã§ãƒ–ãƒ¬ãƒ³ãƒ‰
                        const t = Math.min(1, distToBoundary / 50); // 30â†’50ã«æ‹¡å¤§
                        const smoothT = smoothstep(t);
                        
                        // ä»–ã‚»ãƒ«ã®é«˜åº¦ã‚’è¨ˆç®—
                        let otherHeight = otherCell.baseHeight;
                        if (otherCell.boundaryHeights.size > 0) {
                            let otherMaxHeightDiff = 0;
                            for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                const diff = Math.abs(boundaryHeight - otherCell.baseHeight);
                                otherMaxHeightDiff = Math.max(otherMaxHeightDiff, diff);
                            }
                            const otherInfluenceRange = baseRange + otherMaxHeightDiff * rangeScale;
                            
                            let otherTotalWeight = 0;
                            let otherTotalHeight = 0;
                            
                            for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                const neighbor = voronoi.cells[neighborId];
                                const boundaryX = (otherCell.point.x + neighbor.point.x) / 2;
                                const boundaryY = (otherCell.point.y + neighbor.point.y) / 2;
                                const boundaryPoint = new Point(boundaryX, boundaryY);
                                const distToBoundary = p.distanceTo(boundaryPoint);
                                
                                const weight = 1 / (Math.pow(distToBoundary / otherInfluenceRange, 0.5) + 0.02);
                                otherTotalWeight += weight;
                                otherTotalHeight += boundaryHeight * weight;
                            }
                            
                            const centerDist = otherDist;
                            const centerWeight = 1 / (Math.pow(centerDist / otherInfluenceRange, 0.5) + 0.02);
                            otherTotalWeight += centerWeight;
                            otherTotalHeight += otherCell.baseHeight * centerWeight;
                            
                            otherHeight = otherTotalHeight / otherTotalWeight;
                        }
                        
                        finalHeight = finalHeight * smoothT + otherHeight * (1 - smoothT);
                    }
                }
            }
            
            // ãƒ‘ãƒ¼ãƒªãƒ³ãƒã‚¤ã‚ºã¯ã‚ªãƒ•
            return Math.max(0, Math.min(100, finalHeight));
        }

        function heightToColor(h) {
            if (h < 20) {
                const t = h / 20;
                return {
                    r: Math.floor(0 * (1 - t) + 102 * t),
                    g: Math.floor(102 * (1 - t) + 179 * t),
                    b: Math.floor(204 * (1 - t) + 255 * t)
                };
            } else if (h < 40) {
                const t = (h - 20) / 20;
                return {
                    r: Math.floor(102 * (1 - t) + 144 * t),
                    g: Math.floor(179 * (1 - t) + 238 * t),
                    b: Math.floor(255 * (1 - t) + 144 * t)
                };
            } else if (h < 60) {
                const t = (h - 40) / 20;
                return {
                    r: Math.floor(144 * (1 - t) + 255 * t),
                    g: Math.floor(238 * (1 - t) + 215 * t),
                    b: Math.floor(144 * (1 - t) + 0 * t)
                };
            } else if (h < 80) {
                const t = (h - 60) / 20;
                return {
                    r: Math.floor(255 * (1 - t) + 255 * t),
                    g: Math.floor(215 * (1 - t) + 107 * t),
                    b: Math.floor(0 * (1 - t) + 53 * t)
                };
            } else {
                const t = (h - 80) / 20;
                return {
                    r: Math.floor(255 * (1 - t) + 139 * t),
                    g: Math.floor(107 * (1 - t) + 69 * t),
                    b: Math.floor(53 * (1 - t) + 19 * t)
                };
            }
        }

        function drawStructure(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, width, height);
            
            // ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã«è‰²ã‚’å¡—ã‚‹
            const groupColors = [];
            for (let i = 0; i < voronoi.groups.length; i++) {
                const hue = (i * 137.5) % 360;
                groupColors.push(`hsl(${hue}, 40%, 85%)`);
            }
            
            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    const {cell} = voronoi.getClosestCell(x, y);
                    ctx.fillStyle = groupColors[cell.groupId];
                    ctx.fillRect(x, y, 2, 2);
                }
            }
            
            // ã‚»ãƒ«å¢ƒç•Œã‚’æç”»ï¼ˆè–„ãï¼‰
            const imageData = ctx.createImageData(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const closest = voronoi.getClosestCells(x, y, 2);
                    const diff = closest[1].dist - closest[0].dist;
                    
                    const idx = (y * width + x) * 4;
                    
                    if (diff < 1) {
                        // ã‚»ãƒ«å¢ƒç•Œï¼ˆè–„ã„ã‚°ãƒ¬ãƒ¼ï¼‰
                        imageData.data[idx] = 180;
                        imageData.data[idx + 1] = 180;
                        imageData.data[idx + 2] = 180;
                        imageData.data[idx + 3] = 100;
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            // ã‚°ãƒ«ãƒ¼ãƒ—å¢ƒç•Œã‚’æç”»ï¼ˆå¤ªãã€é€šè·¯/å£ã§è‰²åˆ†ã‘ï¼‰
            const imageData2 = ctx.createImageData(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const closest = voronoi.getClosestCells(x, y, 2);
                    const diff = closest[1].dist - closest[0].dist;
                    
                    const idx = (y * width + x) * 4;
                    
                    if (diff < 1.5) {
                        const group1 = closest[0].cell.groupId;
                        const group2 = closest[1].cell.groupId;
                        
                        if (group1 !== group2) {
                            const isWall = voronoi.getGroupEdge(group1, group2);
                            if (isWall) {
                                // å£ï¼ˆèµ¤ï¼‰
                                imageData2.data[idx] = 244;
                                imageData2.data[idx + 1] = 67;
                                imageData2.data[idx + 2] = 54;
                            } else {
                                // é€šè·¯ï¼ˆç·‘ï¼‰
                                imageData2.data[idx] = 76;
                                imageData2.data[idx + 1] = 175;
                                imageData2.data[idx + 2] = 80;
                            }
                            imageData2.data[idx + 3] = 255;
                        }
                    }
                }
            }
            ctx.putImageData(imageData2, 0, 0);
            
            // ã‚»ãƒ«ä¸­å¿ƒç‚¹
            voronoi.cells.forEach(cell => {
                ctx.beginPath();
                ctx.arc(cell.point.x, cell.point.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = '#666';
                ctx.fill();
            });
        }

        function drawHeightNumbers(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, width, height);
            
            // ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã«è‰²ã‚’å¡—ã‚Šåˆ†ã‘
            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    const {cell} = voronoi.getClosestCell(x, y);
                    const group = voronoi.groups[cell.groupId];
                    const color = heightToColor(group.baseHeight);
                    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`;
                    ctx.fillRect(x, y, 2, 2);
                }
            }
            
            // ã‚°ãƒ«ãƒ¼ãƒ—å¢ƒç•Œã‚’æç”»
            const imageData = ctx.createImageData(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const closest = voronoi.getClosestCells(x, y, 2);
                    const diff = closest[1].dist - closest[0].dist;
                    
                    const idx = (y * width + x) * 4;
                    
                    if (diff < 1.5) {
                        const group1 = closest[0].cell.groupId;
                        const group2 = closest[1].cell.groupId;
                        
                        if (group1 !== group2) {
                            imageData.data[idx] = 60;
                            imageData.data[idx + 1] = 60;
                            imageData.data[idx + 2] = 60;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            // ã‚°ãƒ«ãƒ¼ãƒ—ã®é‡å¿ƒã¨é«˜åº¦ã‚’è¡¨ç¤º
            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            
            voronoi.groups.forEach(group => {
                // ã‚°ãƒ«ãƒ¼ãƒ—ã®é‡å¿ƒã‚’è¨ˆç®—
                let sumX = 0, sumY = 0;
                for (const cellId of group.cells) {
                    sumX += voronoi.cells[cellId].point.x;
                    sumY += voronoi.cells[cellId].point.y;
                }
                const centerX = sumX / group.cells.size;
                const centerY = sumY / group.cells.size;
                
                ctx.fillText(
                    `${group.baseHeight.toFixed(0)}m`,
                    centerX,
                    centerY + 5
                );
            });
            
            // ã‚°ãƒ«ãƒ¼ãƒ—é–“ã®é€šè·¯ã‚’çŸ¢å°ã§æç”»
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#4CAF50';
            
            const drawn = new Set();
            
            voronoi.groups.forEach(group => {
                for (const neighborGroupId of group.neighborGroups) {
                    if (!voronoi.getGroupEdge(group.id, neighborGroupId)) {
                        const key = group.id < neighborGroupId ? 
                            `${group.id}-${neighborGroupId}` : `${neighborGroupId}-${group.id}`;
                        
                        if (drawn.has(key)) continue;
                        drawn.add(key);
                        
                        const neighbor = voronoi.groups[neighborGroupId];
                        
                        // é‡å¿ƒã‚’è¨ˆç®—
                        let sumX1 = 0, sumY1 = 0;
                        for (const cellId of group.cells) {
                            sumX1 += voronoi.cells[cellId].point.x;
                            sumY1 += voronoi.cells[cellId].point.y;
                        }
                        const centerX1 = sumX1 / group.cells.size;
                        const centerY1 = sumY1 / group.cells.size;
                        
                        let sumX2 = 0, sumY2 = 0;
                        for (const cellId of neighbor.cells) {
                            sumX2 += voronoi.cells[cellId].point.x;
                            sumY2 += voronoi.cells[cellId].point.y;
                        }
                        const centerX2 = sumX2 / neighbor.cells.size;
                        const centerY2 = sumY2 / neighbor.cells.size;
                        
                        const dx = centerX2 - centerX1;
                        const dy = centerY2 - centerY1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        
                        const startX = centerX1 + dx / len * 30;
                        const startY = centerY1 + dy / len * 30;
                        const endX = centerX1 + dx / len * (len / 2 - 10);
                        const endY = centerY1 + dy / len * (len / 2 - 10);
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        
                        // çŸ¢å°
                        const angle = Math.atan2(dy, dx);
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(
                            endX - 10 * Math.cos(angle - Math.PI / 6),
                            endY - 10 * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.lineTo(
                            endX - 10 * Math.cos(angle + Math.PI / 6),
                            endY - 10 * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            });
        }

        function drawSmoothTerrain(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const imageData = ctx.createImageData(width, height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const terrainHeight = getImprovedHeight(voronoi, x, y);
                    const color = heightToColor(terrainHeight);
                    
                    const idx = (y * width + x) * 4;
                    imageData.data[idx] = color.r;
                    imageData.data[idx + 1] = color.g;
                    imageData.data[idx + 2] = color.b;
                    imageData.data[idx + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // ç­‰é«˜ç·š
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 1;
            for (let h = 20; h < 100; h += 10) {
                drawContour(ctx, voronoi, width, height, h);
            }
        }

        function drawContour(ctx, voronoi, width, height, targetHeight) {
            const step = 6;
            ctx.beginPath();
            
            for (let y = 0; y < height - step; y += step) {
                for (let x = 0; x < width - step; x += step) {
                    const h1 = getImprovedHeight(voronoi, x, y);
                    const h2 = getImprovedHeight(voronoi, x + step, y);
                    const h3 = getImprovedHeight(voronoi, x, y + step);
                    
                    if ((h1 < targetHeight && h2 >= targetHeight) ||
                        (h1 >= targetHeight && h2 < targetHeight)) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + step, y);
                    }
                    
                    if ((h1 < targetHeight && h3 >= targetHeight) ||
                        (h1 >= targetHeight && h3 < targetHeight)) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, y + step);
                    }
                }
            }
            
            ctx.stroke();
        }

        function drawIsometric3D(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#e8f4f8';
            ctx.fillRect(0, 0, width, height);
            
            // ç­‰è§’æŠ•å½±ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå…¨ä½“ãŒæ˜ ã‚‹ã‚ˆã†ã«èª¿æ•´ï¼‰
            const scale = 0.7; // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ã•ã‚‰ã«å°ã•ãï¼ˆ0.85â†’0.7ï¼‰
            const offsetX = width / 2;
            const offsetY = height * 0.55; // ã‚ˆã‚Šä¸Šã«é…ç½®ï¼ˆ0.75â†’0.55ï¼‰
            const heightScale = 2.0; // é«˜åº¦ã‚’å¼·èª¿
            
            // ã‚«ãƒ¡ãƒ©ã®ä»°è§’ï¼ˆå°‘ã—ä¸Šã‹ã‚‰è¦‹ã‚‹ï¼‰
            const elevationAngle = Math.PI / 12; // 15åº¦ä¸Šã‹ã‚‰
            
            // 3Dåº§æ¨™ã‚’2Dç”»é¢åº§æ¨™ã«å¤‰æ›ï¼ˆç­‰è§’æŠ•å½± + ä»°è§’èª¿æ•´ï¼‰
            function toIso(x, y, z) {
                // ç­‰è§’æŠ•å½±ã®åŸºæœ¬
                const isoX = (x - y) * Math.cos(Math.PI / 6) * scale;
                
                // ä»°è§’ã‚’åŠ å‘³ã—ãŸyåº§æ¨™è¨ˆç®—
                const baseIsoY = (x + y) * Math.sin(Math.PI / 6) * scale;
                const heightOffset = z * heightScale;
                
                // ä»°è§’ã«ã‚ˆã‚‹è£œæ­£ï¼ˆä¸Šã‹ã‚‰è¦‹ã‚‹ã¨æ°´å¹³æˆåˆ†ãŒåœ§ç¸®ã•ã‚Œã‚‹ï¼‰
                const horizontalCompression = Math.cos(elevationAngle);
                const isoY = baseIsoY * horizontalCompression - heightOffset;
                
                return {
                    x: offsetX + isoX,
                    y: offsetY + isoY
                };
            }
            
            // åœ°å½¢ãƒ¡ãƒƒã‚·ãƒ¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
            const meshSize = 80;
            const step = 600 / meshSize;
            const vertices = [];
            
            for (let j = 0; j <= meshSize; j++) {
                for (let i = 0; i <= meshSize; i++) {
                    const x = i * step;
                    const y = j * step;
                    const z = getImprovedHeight(voronoi, x, y);
                    vertices.push({x, y, z});
                }
            }
            
            // é¢ã‚’æç”»ï¼ˆå¾Œã‚ã‹ã‚‰å‰ã¸ï¼‰
            const faces = [];
            for (let j = 0; j < meshSize; j++) {
                for (let i = 0; i < meshSize; i++) {
                    const idx = j * (meshSize + 1) + i;
                    const v1 = vertices[idx];
                    const v2 = vertices[idx + 1];
                    const v3 = vertices[idx + meshSize + 2];
                    const v4 = vertices[idx + meshSize + 1];
                    
                    // é¢ã®å¹³å‡é«˜åº¦ã¨Yåº§æ¨™ï¼ˆã‚½ãƒ¼ãƒˆç”¨ï¼‰
                    const avgZ = (v1.z + v2.z + v3.z + v4.z) / 4;
                    const avgY = (v1.y + v2.y + v3.y + v4.y) / 4;
                    const avgX = (v1.x + v2.x + v3.x + v4.x) / 4;
                    
                    faces.push({
                        vertices: [v1, v2, v3, v4],
                        avgZ,
                        avgY,
                        avgX,
                        sortKey: avgY + avgX // å¥¥ã‹ã‚‰æ‰‹å‰ã¸ã‚½ãƒ¼ãƒˆ
                    });
                }
            }
            
            // å¥¥ã‹ã‚‰æ‰‹å‰ã«ã‚½ãƒ¼ãƒˆ
            faces.sort((a, b) => a.sortKey - b.sortKey);
            
            // é¢ã‚’æç”»
            faces.forEach(face => {
                const {vertices: [v1, v2, v3, v4], avgZ} = face;
                
                const p1 = toIso(v1.x, v1.y, v1.z);
                const p2 = toIso(v2.x, v2.y, v2.z);
                const p3 = toIso(v3.x, v3.y, v3.z);
                const p4 = toIso(v4.x, v4.y, v4.z);
                
                // è‰²ã‚’é«˜åº¦ã§æ±ºå®š
                const color = heightToColor(avgZ);
                
                // é™°å½±ï¼ˆå‚¾æ–œã«å¿œã˜ã¦ï¼‰
                const dx = (v2.z + v3.z) / 2 - (v1.z + v4.z) / 2;
                const dy = (v3.z + v4.z) / 2 - (v1.z + v2.z) / 2;
                const slope = Math.sqrt(dx * dx + dy * dy);
                const shading = Math.max(0.5, 1 - slope * 0.02);
                
                ctx.fillStyle = `rgb(${color.r * shading}, ${color.g * shading}, ${color.b * shading})`;
                ctx.strokeStyle = `rgba(0, 0, 0, ${0.05})`;
                ctx.lineWidth = 0.5;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
            
            // ç­‰é«˜ç·šã‚’3Dã§æç”»
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1.5;
            
            for (let targetHeight = 20; targetHeight < 100; targetHeight += 15) {
                for (let j = 0; j < meshSize; j++) {
                    ctx.beginPath();
                    let started = false;
                    
                    for (let i = 0; i <= meshSize; i++) {
                        const x = i * step;
                        const y = j * step;
                        const z = getImprovedHeight(voronoi, x, y);
                        
                        if (Math.abs(z - targetHeight) < 2) {
                            const p = toIso(x, y, z);
                            if (!started) {
                                ctx.moveTo(p.x, p.y);
                                started = true;
                            } else {
                                ctx.lineTo(p.x, p.y);
                            }
                        }
                    }
                    ctx.stroke();
                }
            }
            
            // ã‚¿ã‚¤ãƒˆãƒ«ã¨èª¬æ˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText('ç­‰è§’æŠ•å½±ã«ã‚ˆã‚‹3Dåœ°å½¢ãƒ“ãƒ¥ãƒ¼ï¼ˆå…¨ä½“è¡¨ç¤ºãƒ»ä¿¯ç°è¦–ç‚¹ï¼‰', 20, 30);
            
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#666';
            ctx.fillText('å°‘ã—ä¸Šã‹ã‚‰è¦‹ãŸåœ°å½¢å…¨ä½“ã€‚é«˜åº¦ã‚’2å€ã«å¼·èª¿è¡¨ç¤ºã€‚æœ€é«˜åœ°ç‚¹ã¨æœ€ä½åœ°ç‚¹ãŒæ˜ç¢ºã€‚', 20, 50);
        }

        let currentVoronoi = null;

        function regenerate() {
            // ç´°ã‹ã„ãƒœãƒ­ãƒã‚¤ï¼ˆ100ã‚»ãƒ«ï¼‰ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆ15å¤§é ˜åŸŸï¼‰
            currentVoronoi = new ImprovedVoronoi(600, 600, 100, 15);
            
            const structureCanvas = document.getElementById('structure');
            const heightNumbersCanvas = document.getElementById('heightNumbers');
            const smoothTerrainCanvas = document.getElementById('smoothTerrain');
            const isometric3DCanvas = document.getElementById('isometric3D');
            
            drawStructure(structureCanvas, currentVoronoi);
            drawHeightNumbers(heightNumbersCanvas, currentVoronoi);
            drawSmoothTerrain(smoothTerrainCanvas, currentVoronoi);
            drawIsometric3D(isometric3DCanvas, currentVoronoi);
        }

        // åˆå›ç”Ÿæˆ
        regenerate();
    </script>
</body>
</html>