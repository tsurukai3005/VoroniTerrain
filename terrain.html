<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>改良版：滑らかなボロノイ地形生成</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-wrapper {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            width: 100%;
            border: 1px solid #ddd;
        }
        h2 {
            margin-top: 0;
            font-size: 18px;
            color: #555;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        .legend-color {
            width: 30px;
            height: 20px;
            border: 1px solid #333;
        }
        .explanation {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .explanation h3 {
            color: #333;
            margin-top: 0;
        }
        .explanation ul {
            line-height: 1.8;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 5px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <h1>改良版：滑らかなボロノイ地形生成</h1>
    
    <div class="controls">
        <button onclick="regenerate()">🔄 地形を再生成</button>
    </div>

    <div class="container">
        <div class="canvas-wrapper">
            <h2>① ボロノイ分割 + 大領域グループ化</h2>
            <canvas id="structure" width="600" height="600"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>通路（緩やかな坂、大領域間）</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>壁（崖、大領域間）</span>
                </div>
                <div class="legend-item">
                    <span>色付き領域：大領域（複数セルの集合）</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <h2>② 高度伝播（大領域単位）</h2>
            <canvas id="heightNumbers" width="600" height="600"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <span>各大領域の基準高度と通路方向</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <h2>③ 滑らかな地形（細部まで傾斜）</h2>
            <canvas id="smoothTerrain" width="600" height="600"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(to right, #0066cc, #66b3ff, #90EE90, #FFD700, #ff6b35, #8B4513);"></div>
                    <span>低 → 高（谷 → 山）セル内部が滑らかに傾斜</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper full-width">
            <h2>④ 三次元俯瞰図（等角投影）</h2>
            <canvas id="isometric3D" width="1200" height="800"></canvas>
        </div>
    </div>

    <div class="explanation">
        <h3>✨ 改良ポイント</h3>
        <ul>
            <li><strong>二段階システム：</strong> 細かいボロノイセル（100個）を大領域（15個、大中小のサイズ差あり）にグループ化。境界は有機的で、通路は広く自然。</li>
            <li><strong>非常に自然な境界線：</strong> 100の細かいセルにより、境界がより滑らかな曲線状に。Lloyd's relaxationで均等配置。</li>
            <li><strong>大中小のサイズ差：</strong> 大領域に大（20%）、中（50%）、小（30%）のサイズバリエーションを追加。より多様な地形に。</li>
            <li><strong>適切な高度差：</strong> 通路で繋がる隣接領域は小さな高度差（5-12m）。前の状態を考慮（上がり傾向・下がり傾向）して高低が生まれやすく。</li>
            <li><strong>非常に広い影響範囲：</strong> 高度差に応じて坂の影響範囲を自動調整（高度差5m→範囲300px、15m→900px）。大領域の中心から坂が始まる。</li>
            <li><strong>滑らかな崖：</strong> 崖の範囲を10-40ピクセルに拡大し、べき乗を1.5に緩和。急峻でも滑らかにつながる。縞模様を解消。</li>
            <li><strong>つづら坂：</strong> セル内部は通路境界に向かって非常に緩やかに傾斜。べき乗0.5で極めて滑らか。</li>
            <li><strong>3D俯瞰図（全体表示）：</strong> 等角投影により地形全体を少し上から可視化。高度を2倍に強調して立体感を表現。</li>
        </ul>
    </div>

    <script>
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        class VoronoiCell {
            constructor(id, point) {
                this.id = id;
                this.point = point;
                this.neighbors = new Set();
                this.groupId = null; // どの大領域に属するか
                this.baseHeight = null;
                this.boundaryHeights = new Map();
            }
        }
        
        class RegionGroup {
            constructor(id) {
                this.id = id;
                this.cells = new Set(); // このグループに属するセル
                this.neighborGroups = new Set(); // 隣接する大領域
                this.baseHeight = null;
            }
        }

        class ImprovedVoronoi {
            constructor(width, height, numSites, numGroups) {
                this.width = width;
                this.height = height;
                this.cells = [];
                this.groups = [];
                this.edges = new Map();
                this.groupEdges = new Map(); // グループ間のエッジ（通路/壁）
                
                // 細かいボロノイセルを生成
                for (let i = 0; i < numSites; i++) {
                    const cell = new VoronoiCell(
                        i,
                        new Point(
                            Math.random() * width,
                            Math.random() * height
                        )
                    );
                    this.cells.push(cell);
                }
                
                // Lloyd's relaxationで母点を均等に配置
                this.relaxLloyd(3);
                
                this.buildNeighborGraph();
                
                // セルをグループ化して大領域を作る
                this.groupCells(numGroups);
                
                // 大領域間で迷路を生成
                this.generateGroupMaze();
                
                // 大領域に高度を割り当て
                this.propagateGroupHeights();
                
                // セルレベルで境界高度を計算
                this.calculateCellBoundaryHeights();
            }
            
            groupCells(numGroups) {
                // シードセルを選択（できるだけ離れた位置）
                const seeds = [];
                seeds.push(Math.floor(Math.random() * this.cells.length));
                
                while (seeds.length < numGroups) {
                    let maxMinDist = -1;
                    let bestCandidate = -1;
                    
                    for (let i = 0; i < this.cells.length; i++) {
                        if (seeds.includes(i)) continue;
                        
                        let minDist = Infinity;
                        for (const seedId of seeds) {
                            const dist = this.cells[i].point.distanceTo(this.cells[seedId].point);
                            minDist = Math.min(minDist, dist);
                        }
                        
                        if (minDist > maxMinDist) {
                            maxMinDist = minDist;
                            bestCandidate = i;
                        }
                    }
                    
                    if (bestCandidate !== -1) {
                        seeds.push(bestCandidate);
                    } else {
                        break;
                    }
                }
                
                // グループを初期化
                for (let i = 0; i < seeds.length; i++) {
                    const group = new RegionGroup(i);
                    this.groups.push(group);
                    
                    const seedCell = this.cells[seeds[i]];
                    seedCell.groupId = i;
                    group.cells.add(seeds[i]);
                }
                
                // 各グループにサイズ（大中小）を割り当て
                const groupSizes = [];
                const numLarge = Math.floor(numGroups * 0.2); // 20%が大
                const numMedium = Math.floor(numGroups * 0.5); // 50%が中
                const numSmall = numGroups - numLarge - numMedium; // 30%が小
                
                for (let i = 0; i < numLarge; i++) groupSizes.push('large');
                for (let i = 0; i < numMedium; i++) groupSizes.push('medium');
                for (let i = 0; i < numSmall; i++) groupSizes.push('small');
                
                // シャッフル
                groupSizes.sort(() => Math.random() - 0.5);
                
                // 各グループのサイズを設定
                this.groups.forEach((group, i) => {
                    group.targetSize = groupSizes[i];
                });
                
                // サイズを考慮したグローイング法で各セルをグループに割り当て
                const queue = seeds.map(id => ({cellId: id, groupId: this.cells[id].groupId}));
                const visited = new Set(seeds);
                
                while (queue.length > 0) {
                    const {cellId, groupId} = queue.shift();
                    const group = this.groups[groupId];
                    
                    // このグループの目標サイズ
                    const totalCells = this.cells.length;
                    let targetCells;
                    if (group.targetSize === 'large') {
                        targetCells = Math.floor(totalCells / numGroups * 1.8); // 1.8倍
                    } else if (group.targetSize === 'medium') {
                        targetCells = Math.floor(totalCells / numGroups * 1.0); // 標準
                    } else {
                        targetCells = Math.floor(totalCells / numGroups * 0.6); // 0.6倍
                    }
                    
                    // 目標サイズに達していない場合のみ拡大
                    if (group.cells.size < targetCells) {
                        for (const neighborId of this.cells[cellId].neighbors) {
                            if (!visited.has(neighborId)) {
                                visited.add(neighborId);
                                this.cells[neighborId].groupId = groupId;
                                this.groups[groupId].cells.add(neighborId);
                                queue.push({cellId: neighborId, groupId});
                            }
                        }
                    }
                }
                
                // 未割り当てのセルがあれば最も近いグループに割り当て
                for (let i = 0; i < this.cells.length; i++) {
                    if (!visited.has(i)) {
                        let minDist = Infinity;
                        let closestGroupId = 0;
                        
                        for (let g = 0; g < this.groups.length; g++) {
                            for (const cellId of this.groups[g].cells) {
                                const dist = this.cells[i].point.distanceTo(this.cells[cellId].point);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestGroupId = g;
                                }
                            }
                        }
                        
                        this.cells[i].groupId = closestGroupId;
                        this.groups[closestGroupId].cells.add(i);
                    }
                }
                
                // グループ間の隣接関係を構築
                for (let i = 0; i < this.cells.length; i++) {
                    const cell = this.cells[i];
                    for (const neighborId of cell.neighbors) {
                        const neighbor = this.cells[neighborId];
                        if (cell.groupId !== neighbor.groupId) {
                            this.groups[cell.groupId].neighborGroups.add(neighbor.groupId);
                            this.groups[neighbor.groupId].neighborGroups.add(cell.groupId);
                        }
                    }
                }
            }
            
            generateGroupMaze() {
                // グループ間で迷路を生成（Prim法）
                const visited = new Set([0]);
                const edges = [];
                
                for (const neighborGroupId of this.groups[0].neighborGroups) {
                    edges.push([0, neighborGroupId]);
                }
                
                while (visited.size < this.groups.length && edges.length > 0) {
                    const idx = Math.floor(Math.random() * edges.length);
                    const [from, to] = edges[idx];
                    edges.splice(idx, 1);
                    
                    if (!visited.has(to)) {
                        visited.add(to);
                        this.setGroupEdge(from, to, false); // 通路
                        
                        for (const neighborGroupId of this.groups[to].neighborGroups) {
                            if (!visited.has(neighborGroupId)) {
                                edges.push([to, neighborGroupId]);
                            }
                        }
                    }
                }
                
                // 残りは壁
                for (let i = 0; i < this.groups.length; i++) {
                    for (const j of this.groups[i].neighborGroups) {
                        if (i < j && !this.hasGroupEdge(i, j)) {
                            this.setGroupEdge(i, j, true); // 壁
                        }
                    }
                }
            }
            
            setGroupEdge(i, j, isWall) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                this.groupEdges.set(key, isWall);
            }
            
            getGroupEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.groupEdges.get(key) || false;
            }
            
            hasGroupEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.groupEdges.has(key);
            }
            
            relaxLloyd(iterations) {
                // Lloyd's relaxation: 各セルの重心に母点を移動
                for (let iter = 0; iter < iterations; iter++) {
                    const centroids = [];
                    
                    // 各セルの重心を計算
                    for (let i = 0; i < this.cells.length; i++) {
                        let sumX = 0;
                        let sumY = 0;
                        let count = 0;
                        
                        // サンプリングでセル領域をカバー
                        const step = 8;
                        for (let y = 0; y < this.height; y += step) {
                            for (let x = 0; x < this.width; x += step) {
                                const p = new Point(x, y);
                                let closestId = 0;
                                let minDist = this.cells[0].point.distanceTo(p);
                                
                                for (let j = 1; j < this.cells.length; j++) {
                                    const dist = this.cells[j].point.distanceTo(p);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        closestId = j;
                                    }
                                }
                                
                                if (closestId === i) {
                                    sumX += x;
                                    sumY += y;
                                    count++;
                                }
                            }
                        }
                        
                        if (count > 0) {
                            centroids.push(new Point(sumX / count, sumY / count));
                        } else {
                            centroids.push(this.cells[i].point);
                        }
                    }
                    
                    // 母点を重心に移動
                    for (let i = 0; i < this.cells.length; i++) {
                        this.cells[i].point = centroids[i];
                    }
                }
            }
            
            buildNeighborGraph() {
                const step = 5;
                for (let y = 0; y < this.height; y += step) {
                    for (let x = 0; x < this.width; x += step) {
                        const p = new Point(x, y);
                        const sorted = this.cells
                            .map(c => ({cell: c, dist: c.point.distanceTo(p)}))
                            .sort((a, b) => a.dist - b.dist);
                        
                        if (sorted.length >= 2 && sorted[1].dist - sorted[0].dist < 3) {
                            const c1 = sorted[0].cell;
                            const c2 = sorted[1].cell;
                            c1.neighbors.add(c2.id);
                            c2.neighbors.add(c1.id);
                        }
                    }
                }
            }
            
            generateMaze() {
                const visited = new Set([0]);
                const edges = [];
                
                for (const neighbor of this.cells[0].neighbors) {
                    edges.push([0, neighbor]);
                }
                
                while (visited.size < this.cells.length && edges.length > 0) {
                    const idx = Math.floor(Math.random() * edges.length);
                    const [from, to] = edges[idx];
                    edges.splice(idx, 1);
                    
                    if (!visited.has(to)) {
                        visited.add(to);
                        this.setEdge(from, to, false);
                        
                        for (const neighbor of this.cells[to].neighbors) {
                            if (!visited.has(neighbor)) {
                                edges.push([to, neighbor]);
                            }
                        }
                    }
                }
                
                for (let i = 0; i < this.cells.length; i++) {
                    for (const j of this.cells[i].neighbors) {
                        if (i < j && !this.hasEdge(i, j)) {
                            this.setEdge(i, j, true);
                        }
                    }
                }
            }
            
            propagateGroupHeights() {
                // 幅優先探索で高度を割り当て
                const startGroup = this.groups[0];
                startGroup.baseHeight = 40 + Math.random() * 20; // 開始高度（30-60m）
                
                const visited = new Set([startGroup.id]);
                const queue = [{group: startGroup, lastDirection: null}]; // 前回の方向を記録
                
                while (queue.length > 0) {
                    const {group: current, lastDirection} = queue.shift();
                    
                    // 通路で繋がる未訪問の隣接グループを集める
                    const children = [];
                    for (const neighborGroupId of current.neighborGroups) {
                        if (!this.getGroupEdge(current.id, neighborGroupId) && !visited.has(neighborGroupId)) {
                            children.push(neighborGroupId);
                        }
                    }
                    
                    // 各子グループに高度を割り当て
                    children.forEach(neighborGroupId => {
                        visited.add(neighborGroupId);
                        const neighbor = this.groups[neighborGroupId];
                        
                        // 通路で繋がっているので小さな高度差（5-12m）
                        const heightDiff = 5 + Math.random() * 7;
                        
                        // 前回の方向を考慮した確率調整
                        let upProbability;
                        if (lastDirection === 'up') {
                            upProbability = 0.75; // 前回上がっていたら75%で上がる
                        } else if (lastDirection === 'down') {
                            upProbability = 0.25; // 前回下がっていたら25%で上がる（75%で下がる）
                        } else {
                            upProbability = 0.55; // 初回は少し上がりやすく
                        }
                        
                        const goUp = Math.random() < upProbability;
                        const newDirection = goUp ? 'up' : 'down';
                        
                        if (goUp) {
                            neighbor.baseHeight = Math.min(90, current.baseHeight + heightDiff);
                        } else {
                            neighbor.baseHeight = Math.max(10, current.baseHeight - heightDiff);
                        }
                        
                        queue.push({group: neighbor, lastDirection: newDirection});
                    });
                }
                
                // 壁で隔てられた隣接グループの高度差を確保
                this.ensureGroupWallHeightDifference();
            }
            
            ensureGroupWallHeightDifference() {
                const minDifference = 15;
                
                for (let i = 0; i < this.groups.length; i++) {
                    for (const j of this.groups[i].neighborGroups) {
                        if (i < j && this.getGroupEdge(i, j)) {
                            const group1 = this.groups[i];
                            const group2 = this.groups[j];
                            
                            if (group1.baseHeight == null || group2.baseHeight == null) continue;
                            
                            const diff = Math.abs(group1.baseHeight - group2.baseHeight);
                            if (diff < minDifference) {
                                if (group1.baseHeight > group2.baseHeight) {
                                    group1.baseHeight = Math.min(95, group2.baseHeight + minDifference + Math.random() * 10);
                                } else {
                                    group2.baseHeight = Math.min(95, group1.baseHeight + minDifference + Math.random() * 10);
                                }
                            }
                        }
                    }
                }
            }
            
            calculateCellBoundaryHeights() {
                // 各セルに所属グループの高度を割り当て
                for (const cell of this.cells) {
                    const group = this.groups[cell.groupId];
                    cell.baseHeight = group.baseHeight;
                }
                
                // セル間の境界高度を計算
                for (const cell of this.cells) {
                    for (const neighborId of cell.neighbors) {
                        const neighbor = this.cells[neighborId];
                        
                        // 同じグループ内 or グループ間が通路の場合
                        if (cell.groupId === neighbor.groupId || 
                            !this.getGroupEdge(cell.groupId, neighbor.groupId)) {
                            const boundaryHeight = (cell.baseHeight + neighbor.baseHeight) / 2;
                            cell.boundaryHeights.set(neighborId, boundaryHeight);
                        }
                    }
                }
            }
            
            setEdge(i, j, isWall) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                this.edges.set(key, isWall);
            }
            
            getEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.edges.get(key) || false;
            }
            
            hasEdge(i, j) {
                const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                return this.edges.has(key);
            }
            
            getClosestCell(x, y) {
                const p = new Point(x, y);
                let closest = this.cells[0];
                let minDist = closest.point.distanceTo(p);
                
                for (let i = 1; i < this.cells.length; i++) {
                    const dist = this.cells[i].point.distanceTo(p);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = this.cells[i];
                    }
                }
                
                return {cell: closest, dist: minDist};
            }
            
            getClosestCells(x, y, n = 3) {
                const p = new Point(x, y);
                return this.cells
                    .map(c => ({cell: c, dist: c.point.distanceTo(p)}))
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, n);
            }
        }

        // パーリンノイズ風の関数
        function simpleNoise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const fx = x - Math.floor(x);
            const fy = y - Math.floor(y);
            
            const hash = (X * 374761393 + Y * 668265263) & 0x7fffffff;
            return (hash / 0x7fffffff) * 2 - 1;
        }

        function perlinNoise(x, y) {
            const X = Math.floor(x);
            const Y = Math.floor(y);
            const fx = x - X;
            const fy = y - Y;
            
            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const u = fade(fx);
            const v = fade(fy);
            
            const n00 = simpleNoise(X, Y);
            const n10 = simpleNoise(X + 1, Y);
            const n01 = simpleNoise(X, Y + 1);
            const n11 = simpleNoise(X + 1, Y + 1);
            
            const nx0 = n00 * (1 - u) + n10 * u;
            const nx1 = n01 * (1 - u) + n11 * u;
            
            return nx0 * (1 - v) + nx1 * v;
        }

        function multiOctaveNoise(x, y) {
            let total = 0;
            let amplitude = 1;
            let frequency = 0.01;
            
            for (let i = 0; i < 4; i++) {
                total += perlinNoise(x * frequency, y * frequency) * amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return total;
        }

        // 改良版の高度計算（縞模様を除去）
        function smoothstep(t) {
            t = Math.max(0, Math.min(1, t));
            return t * t * (3 - 2 * t);
        }

        function getImprovedHeight(voronoi, x, y) {
            const p = new Point(x, y);
            
            // 最も近いセルを取得
            const closest = voronoi.getClosestCells(x, y, 5);
            const primaryCell = closest[0].cell;
            
            if (primaryCell.baseHeight == null) return 50;
            
            // ステップ1: このセルに関連する高度差を計算
            let maxHeightDiff = 0;
            if (primaryCell.boundaryHeights.size > 0) {
                for (const [neighborId, boundaryHeight] of primaryCell.boundaryHeights) {
                    const diff = Math.abs(boundaryHeight - primaryCell.baseHeight);
                    maxHeightDiff = Math.max(maxHeightDiff, diff);
                }
            }
            
            // 高度差に応じて影響範囲を決定（大幅に広げる）
            // 高度差5m → 範囲300、高度差15m → 範囲900（大領域の中心から坂が始まる）
            const baseRange = 300;
            const rangeScale = 60; // 高度差1mあたり60ピクセル拡大（30→60に倍増）
            const influenceRange = baseRange + maxHeightDiff * rangeScale;
            
            // ステップ2: 領域全体の緩やかな傾斜を計算（つづら坂）
            let baseHeight = primaryCell.baseHeight;
            
            // 通路で繋がっている隣接セルへの傾斜を計算
            if (primaryCell.boundaryHeights.size > 0) {
                let totalWeight = 0;
                let totalHeight = 0;
                
                // 各通路境界からの影響を計算（非常に広い範囲で）
                for (const [neighborId, boundaryHeight] of primaryCell.boundaryHeights) {
                    const neighbor = voronoi.cells[neighborId];
                    
                    // 境界の中点
                    const boundaryX = (primaryCell.point.x + neighbor.point.x) / 2;
                    const boundaryY = (primaryCell.point.y + neighbor.point.y) / 2;
                    const boundaryPoint = new Point(boundaryX, boundaryY);
                    const distToBoundary = p.distanceTo(boundaryPoint);
                    
                    // 非常に緩やかな重み付け（より緩やかに）
                    const weight = 1 / (Math.pow(distToBoundary / influenceRange, 0.5) + 0.02);
                    totalWeight += weight;
                    totalHeight += boundaryHeight * weight;
                }
                
                // セル中心の影響
                const centerDist = closest[0].dist;
                const centerWeight = 1 / (Math.pow(centerDist / influenceRange, 0.5) + 0.02);
                totalWeight += centerWeight;
                totalHeight += primaryCell.baseHeight * centerWeight;
                
                baseHeight = totalHeight / totalWeight;
            }
            
            // ステップ3: セル境界付近での隣接セルとのブレンド
            let finalHeight = baseHeight;
            
            // 隣接セルとの境界処理
            for (let i = 1; i < Math.min(4, closest.length); i++) {
                const {cell: otherCell, dist: otherDist} = closest[i];
                
                if (otherCell.baseHeight == null) continue;
                
                const distToBoundary = otherDist - closest[0].dist;
                
                // 境界に近い場合
                if (distToBoundary < 50) { // 30→50に拡大
                    // このセルとの境界が壁かどうか確認
                    const isWall = voronoi.getEdge(primaryCell.id, otherCell.id);
                    
                    if (isWall) {
                        // 壁の場合：高度差に応じた崖を作る
                        const heightDiff = Math.abs(primaryCell.baseHeight - otherCell.baseHeight);
                        
                        // 高度差に応じて崖の範囲を調整（大幅に広げる）
                        const cliffRange = Math.min(40, 10 + heightDiff * 1.5); // 範囲を10-40ピクセルに拡大
                        
                        if (distToBoundary < cliffRange) {
                            // 境界付近で変化（より滑らかに）
                            const t = distToBoundary / cliffRange;
                            const sharpT = Math.pow(t, 1.5); // 2.5→1.5に緩和（より滑らか）
                            
                            // 他セルの高度を計算
                            let otherHeight = otherCell.baseHeight;
                            if (otherCell.boundaryHeights.size > 0) {
                                let otherMaxHeightDiff = 0;
                                for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                    const diff = Math.abs(boundaryHeight - otherCell.baseHeight);
                                    otherMaxHeightDiff = Math.max(otherMaxHeightDiff, diff);
                                }
                                const otherInfluenceRange = baseRange + otherMaxHeightDiff * rangeScale;
                                
                                let otherTotalWeight = 0;
                                let otherTotalHeight = 0;
                                
                                for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                    const neighbor = voronoi.cells[neighborId];
                                    const boundaryX = (otherCell.point.x + neighbor.point.x) / 2;
                                    const boundaryY = (otherCell.point.y + neighbor.point.y) / 2;
                                    const boundaryPoint = new Point(boundaryX, boundaryY);
                                    const distToBoundary = p.distanceTo(boundaryPoint);
                                    
                                    const weight = 1 / (Math.pow(distToBoundary / otherInfluenceRange, 0.5) + 0.02);
                                    otherTotalWeight += weight;
                                    otherTotalHeight += boundaryHeight * weight;
                                }
                                
                                const centerDist = otherDist;
                                const centerWeight = 1 / (Math.pow(centerDist / otherInfluenceRange, 0.5) + 0.02);
                                otherTotalWeight += centerWeight;
                                otherTotalHeight += otherCell.baseHeight * centerWeight;
                                
                                otherHeight = otherTotalHeight / otherTotalWeight;
                            }
                            
                            finalHeight = finalHeight * sharpT + otherHeight * (1 - sharpT);
                        }
                    } else {
                        // 通路の場合：緩やかな傾斜でブレンド
                        const t = Math.min(1, distToBoundary / 50); // 30→50に拡大
                        const smoothT = smoothstep(t);
                        
                        // 他セルの高度を計算
                        let otherHeight = otherCell.baseHeight;
                        if (otherCell.boundaryHeights.size > 0) {
                            let otherMaxHeightDiff = 0;
                            for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                const diff = Math.abs(boundaryHeight - otherCell.baseHeight);
                                otherMaxHeightDiff = Math.max(otherMaxHeightDiff, diff);
                            }
                            const otherInfluenceRange = baseRange + otherMaxHeightDiff * rangeScale;
                            
                            let otherTotalWeight = 0;
                            let otherTotalHeight = 0;
                            
                            for (const [neighborId, boundaryHeight] of otherCell.boundaryHeights) {
                                const neighbor = voronoi.cells[neighborId];
                                const boundaryX = (otherCell.point.x + neighbor.point.x) / 2;
                                const boundaryY = (otherCell.point.y + neighbor.point.y) / 2;
                                const boundaryPoint = new Point(boundaryX, boundaryY);
                                const distToBoundary = p.distanceTo(boundaryPoint);
                                
                                const weight = 1 / (Math.pow(distToBoundary / otherInfluenceRange, 0.5) + 0.02);
                                otherTotalWeight += weight;
                                otherTotalHeight += boundaryHeight * weight;
                            }
                            
                            const centerDist = otherDist;
                            const centerWeight = 1 / (Math.pow(centerDist / otherInfluenceRange, 0.5) + 0.02);
                            otherTotalWeight += centerWeight;
                            otherTotalHeight += otherCell.baseHeight * centerWeight;
                            
                            otherHeight = otherTotalHeight / otherTotalWeight;
                        }
                        
                        finalHeight = finalHeight * smoothT + otherHeight * (1 - smoothT);
                    }
                }
            }
            
            // パーリンノイズはオフ
            return Math.max(0, Math.min(100, finalHeight));
        }

        function heightToColor(h) {
            if (h < 20) {
                const t = h / 20;
                return {
                    r: Math.floor(0 * (1 - t) + 102 * t),
                    g: Math.floor(102 * (1 - t) + 179 * t),
                    b: Math.floor(204 * (1 - t) + 255 * t)
                };
            } else if (h < 40) {
                const t = (h - 20) / 20;
                return {
                    r: Math.floor(102 * (1 - t) + 144 * t),
                    g: Math.floor(179 * (1 - t) + 238 * t),
                    b: Math.floor(255 * (1 - t) + 144 * t)
                };
            } else if (h < 60) {
                const t = (h - 40) / 20;
                return {
                    r: Math.floor(144 * (1 - t) + 255 * t),
                    g: Math.floor(238 * (1 - t) + 215 * t),
                    b: Math.floor(144 * (1 - t) + 0 * t)
                };
            } else if (h < 80) {
                const t = (h - 60) / 20;
                return {
                    r: Math.floor(255 * (1 - t) + 255 * t),
                    g: Math.floor(215 * (1 - t) + 107 * t),
                    b: Math.floor(0 * (1 - t) + 53 * t)
                };
            } else {
                const t = (h - 80) / 20;
                return {
                    r: Math.floor(255 * (1 - t) + 139 * t),
                    g: Math.floor(107 * (1 - t) + 69 * t),
                    b: Math.floor(53 * (1 - t) + 19 * t)
                };
            }
        }

        function drawStructure(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, width, height);
            
            // グループごとに色を塗る
            const groupColors = [];
            for (let i = 0; i < voronoi.groups.length; i++) {
                const hue = (i * 137.5) % 360;
                groupColors.push(`hsl(${hue}, 40%, 85%)`);
            }
            
            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    const {cell} = voronoi.getClosestCell(x, y);
                    ctx.fillStyle = groupColors[cell.groupId];
                    ctx.fillRect(x, y, 2, 2);
                }
            }
            
            // セル境界を描画（薄く）
            const imageData = ctx.createImageData(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const closest = voronoi.getClosestCells(x, y, 2);
                    const diff = closest[1].dist - closest[0].dist;
                    
                    const idx = (y * width + x) * 4;
                    
                    if (diff < 1) {
                        // セル境界（薄いグレー）
                        imageData.data[idx] = 180;
                        imageData.data[idx + 1] = 180;
                        imageData.data[idx + 2] = 180;
                        imageData.data[idx + 3] = 100;
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            // グループ境界を描画（太く、通路/壁で色分け）
            const imageData2 = ctx.createImageData(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const closest = voronoi.getClosestCells(x, y, 2);
                    const diff = closest[1].dist - closest[0].dist;
                    
                    const idx = (y * width + x) * 4;
                    
                    if (diff < 1.5) {
                        const group1 = closest[0].cell.groupId;
                        const group2 = closest[1].cell.groupId;
                        
                        if (group1 !== group2) {
                            const isWall = voronoi.getGroupEdge(group1, group2);
                            if (isWall) {
                                // 壁（赤）
                                imageData2.data[idx] = 244;
                                imageData2.data[idx + 1] = 67;
                                imageData2.data[idx + 2] = 54;
                            } else {
                                // 通路（緑）
                                imageData2.data[idx] = 76;
                                imageData2.data[idx + 1] = 175;
                                imageData2.data[idx + 2] = 80;
                            }
                            imageData2.data[idx + 3] = 255;
                        }
                    }
                }
            }
            ctx.putImageData(imageData2, 0, 0);
            
            // セル中心点
            voronoi.cells.forEach(cell => {
                ctx.beginPath();
                ctx.arc(cell.point.x, cell.point.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = '#666';
                ctx.fill();
            });
        }

        function drawHeightNumbers(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, width, height);
            
            // グループごとに色を塗り分け
            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    const {cell} = voronoi.getClosestCell(x, y);
                    const group = voronoi.groups[cell.groupId];
                    const color = heightToColor(group.baseHeight);
                    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`;
                    ctx.fillRect(x, y, 2, 2);
                }
            }
            
            // グループ境界を描画
            const imageData = ctx.createImageData(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const closest = voronoi.getClosestCells(x, y, 2);
                    const diff = closest[1].dist - closest[0].dist;
                    
                    const idx = (y * width + x) * 4;
                    
                    if (diff < 1.5) {
                        const group1 = closest[0].cell.groupId;
                        const group2 = closest[1].cell.groupId;
                        
                        if (group1 !== group2) {
                            imageData.data[idx] = 60;
                            imageData.data[idx + 1] = 60;
                            imageData.data[idx + 2] = 60;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            // グループの重心と高度を表示
            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            
            voronoi.groups.forEach(group => {
                // グループの重心を計算
                let sumX = 0, sumY = 0;
                for (const cellId of group.cells) {
                    sumX += voronoi.cells[cellId].point.x;
                    sumY += voronoi.cells[cellId].point.y;
                }
                const centerX = sumX / group.cells.size;
                const centerY = sumY / group.cells.size;
                
                ctx.fillText(
                    `${group.baseHeight.toFixed(0)}m`,
                    centerX,
                    centerY + 5
                );
            });
            
            // グループ間の通路を矢印で描画
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#4CAF50';
            
            const drawn = new Set();
            
            voronoi.groups.forEach(group => {
                for (const neighborGroupId of group.neighborGroups) {
                    if (!voronoi.getGroupEdge(group.id, neighborGroupId)) {
                        const key = group.id < neighborGroupId ? 
                            `${group.id}-${neighborGroupId}` : `${neighborGroupId}-${group.id}`;
                        
                        if (drawn.has(key)) continue;
                        drawn.add(key);
                        
                        const neighbor = voronoi.groups[neighborGroupId];
                        
                        // 重心を計算
                        let sumX1 = 0, sumY1 = 0;
                        for (const cellId of group.cells) {
                            sumX1 += voronoi.cells[cellId].point.x;
                            sumY1 += voronoi.cells[cellId].point.y;
                        }
                        const centerX1 = sumX1 / group.cells.size;
                        const centerY1 = sumY1 / group.cells.size;
                        
                        let sumX2 = 0, sumY2 = 0;
                        for (const cellId of neighbor.cells) {
                            sumX2 += voronoi.cells[cellId].point.x;
                            sumY2 += voronoi.cells[cellId].point.y;
                        }
                        const centerX2 = sumX2 / neighbor.cells.size;
                        const centerY2 = sumY2 / neighbor.cells.size;
                        
                        const dx = centerX2 - centerX1;
                        const dy = centerY2 - centerY1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        
                        const startX = centerX1 + dx / len * 30;
                        const startY = centerY1 + dy / len * 30;
                        const endX = centerX1 + dx / len * (len / 2 - 10);
                        const endY = centerY1 + dy / len * (len / 2 - 10);
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        
                        // 矢印
                        const angle = Math.atan2(dy, dx);
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(
                            endX - 10 * Math.cos(angle - Math.PI / 6),
                            endY - 10 * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.lineTo(
                            endX - 10 * Math.cos(angle + Math.PI / 6),
                            endY - 10 * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            });
        }

        function drawSmoothTerrain(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const imageData = ctx.createImageData(width, height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const terrainHeight = getImprovedHeight(voronoi, x, y);
                    const color = heightToColor(terrainHeight);
                    
                    const idx = (y * width + x) * 4;
                    imageData.data[idx] = color.r;
                    imageData.data[idx + 1] = color.g;
                    imageData.data[idx + 2] = color.b;
                    imageData.data[idx + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // 等高線
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 1;
            for (let h = 20; h < 100; h += 10) {
                drawContour(ctx, voronoi, width, height, h);
            }
        }

        function drawContour(ctx, voronoi, width, height, targetHeight) {
            const step = 6;
            ctx.beginPath();
            
            for (let y = 0; y < height - step; y += step) {
                for (let x = 0; x < width - step; x += step) {
                    const h1 = getImprovedHeight(voronoi, x, y);
                    const h2 = getImprovedHeight(voronoi, x + step, y);
                    const h3 = getImprovedHeight(voronoi, x, y + step);
                    
                    if ((h1 < targetHeight && h2 >= targetHeight) ||
                        (h1 >= targetHeight && h2 < targetHeight)) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + step, y);
                    }
                    
                    if ((h1 < targetHeight && h3 >= targetHeight) ||
                        (h1 >= targetHeight && h3 < targetHeight)) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, y + step);
                    }
                }
            }
            
            ctx.stroke();
        }

        function drawIsometric3D(canvas, voronoi) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#e8f4f8';
            ctx.fillRect(0, 0, width, height);
            
            // 等角投影のパラメータ（全体が映るように調整）
            const scale = 0.7; // スケールをさらに小さく（0.85→0.7）
            const offsetX = width / 2;
            const offsetY = height * 0.55; // より上に配置（0.75→0.55）
            const heightScale = 2.0; // 高度を強調
            
            // カメラの仰角（少し上から見る）
            const elevationAngle = Math.PI / 12; // 15度上から
            
            // 3D座標を2D画面座標に変換（等角投影 + 仰角調整）
            function toIso(x, y, z) {
                // 等角投影の基本
                const isoX = (x - y) * Math.cos(Math.PI / 6) * scale;
                
                // 仰角を加味したy座標計算
                const baseIsoY = (x + y) * Math.sin(Math.PI / 6) * scale;
                const heightOffset = z * heightScale;
                
                // 仰角による補正（上から見ると水平成分が圧縮される）
                const horizontalCompression = Math.cos(elevationAngle);
                const isoY = baseIsoY * horizontalCompression - heightOffset;
                
                return {
                    x: offsetX + isoX,
                    y: offsetY + isoY
                };
            }
            
            // 地形メッシュのデータを準備
            const meshSize = 80;
            const step = 600 / meshSize;
            const vertices = [];
            
            for (let j = 0; j <= meshSize; j++) {
                for (let i = 0; i <= meshSize; i++) {
                    const x = i * step;
                    const y = j * step;
                    const z = getImprovedHeight(voronoi, x, y);
                    vertices.push({x, y, z});
                }
            }
            
            // 面を描画（後ろから前へ）
            const faces = [];
            for (let j = 0; j < meshSize; j++) {
                for (let i = 0; i < meshSize; i++) {
                    const idx = j * (meshSize + 1) + i;
                    const v1 = vertices[idx];
                    const v2 = vertices[idx + 1];
                    const v3 = vertices[idx + meshSize + 2];
                    const v4 = vertices[idx + meshSize + 1];
                    
                    // 面の平均高度とY座標（ソート用）
                    const avgZ = (v1.z + v2.z + v3.z + v4.z) / 4;
                    const avgY = (v1.y + v2.y + v3.y + v4.y) / 4;
                    const avgX = (v1.x + v2.x + v3.x + v4.x) / 4;
                    
                    faces.push({
                        vertices: [v1, v2, v3, v4],
                        avgZ,
                        avgY,
                        avgX,
                        sortKey: avgY + avgX // 奥から手前へソート
                    });
                }
            }
            
            // 奥から手前にソート
            faces.sort((a, b) => a.sortKey - b.sortKey);
            
            // 面を描画
            faces.forEach(face => {
                const {vertices: [v1, v2, v3, v4], avgZ} = face;
                
                const p1 = toIso(v1.x, v1.y, v1.z);
                const p2 = toIso(v2.x, v2.y, v2.z);
                const p3 = toIso(v3.x, v3.y, v3.z);
                const p4 = toIso(v4.x, v4.y, v4.z);
                
                // 色を高度で決定
                const color = heightToColor(avgZ);
                
                // 陰影（傾斜に応じて）
                const dx = (v2.z + v3.z) / 2 - (v1.z + v4.z) / 2;
                const dy = (v3.z + v4.z) / 2 - (v1.z + v2.z) / 2;
                const slope = Math.sqrt(dx * dx + dy * dy);
                const shading = Math.max(0.5, 1 - slope * 0.02);
                
                ctx.fillStyle = `rgb(${color.r * shading}, ${color.g * shading}, ${color.b * shading})`;
                ctx.strokeStyle = `rgba(0, 0, 0, ${0.05})`;
                ctx.lineWidth = 0.5;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
            
            // 等高線を3Dで描画
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1.5;
            
            for (let targetHeight = 20; targetHeight < 100; targetHeight += 15) {
                for (let j = 0; j < meshSize; j++) {
                    ctx.beginPath();
                    let started = false;
                    
                    for (let i = 0; i <= meshSize; i++) {
                        const x = i * step;
                        const y = j * step;
                        const z = getImprovedHeight(voronoi, x, y);
                        
                        if (Math.abs(z - targetHeight) < 2) {
                            const p = toIso(x, y, z);
                            if (!started) {
                                ctx.moveTo(p.x, p.y);
                                started = true;
                            } else {
                                ctx.lineTo(p.x, p.y);
                            }
                        }
                    }
                    ctx.stroke();
                }
            }
            
            // タイトルと説明
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText('等角投影による3D地形ビュー（全体表示・俯瞰視点）', 20, 30);
            
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#666';
            ctx.fillText('少し上から見た地形全体。高度を2倍に強調表示。最高地点と最低地点が明確。', 20, 50);
        }

        let currentVoronoi = null;

        function regenerate() {
            // 細かいボロノイ（100セル）をグループ化（15大領域）
            currentVoronoi = new ImprovedVoronoi(600, 600, 100, 15);
            
            const structureCanvas = document.getElementById('structure');
            const heightNumbersCanvas = document.getElementById('heightNumbers');
            const smoothTerrainCanvas = document.getElementById('smoothTerrain');
            const isometric3DCanvas = document.getElementById('isometric3D');
            
            drawStructure(structureCanvas, currentVoronoi);
            drawHeightNumbers(heightNumbersCanvas, currentVoronoi);
            drawSmoothTerrain(smoothTerrainCanvas, currentVoronoi);
            drawIsometric3D(isometric3DCanvas, currentVoronoi);
        }

        // 初回生成
        regenerate();
    </script>
</body>
</html>